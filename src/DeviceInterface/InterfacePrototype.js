import {
    ADDRESS_DOMAIN,
    SIGN_IN_MSG,
    sendAndWaitForAnswer,
    formatDuckAddress,
    autofillEnabled,
    notifyWebApp, getDaxBoundingBox, isAutofillEnabledFromProcessedConfig, setValue
} from '../autofill-utils.js'

import {getInputType, getMainTypeFromType, getSubtypeFromType} from '../Form/matching.js'
import {formatFullName} from '../Form/formatters.js'
import {fromPassword, appendGeneratedId, AUTOGENERATED_KEY, PROVIDER_LOCKED} from '../InputTypes/Credentials.js'
import {PasswordGenerator} from '../PasswordGenerator.js'
import {createScanner} from '../Scanner.js'
import {createGlobalConfig} from '../config.js'
import {createTransport} from '../deviceApiCalls/transports/transports.js'
import {Settings} from '../Settings.js'
import {createNotification, createRequest, DeviceApi, validate} from '../../packages/device-api/index.js'
import {
    GetAutofillCredentialsCall,
    StoreFormDataCall,
    AskToUnlockProviderCall,
    SendJSPixelCall,
    CheckCredentialsProviderStatusCall,
    GetAutofillInitDataCall,
    SetSizeCall,
    GetAutofillDataCall,
    CloseAutofillParentCall,
    SetIncontextSignupPermanentlyDismissedAtCall,
    SetIncontextSignupInitiallyDismissedAtCall, SelectedDetailCall
} from '../deviceApiCalls/__generated__/deviceApiCalls.js'
import {initFormSubmissionsApi} from './initFormSubmissionsApi.js'
import {providerStatusUpdatedSchema} from '../deviceApiCalls/__generated__/validators.zod.js'
import {processConfig} from "@duckduckgo/content-scope-scripts/src/apple-utils";
import {NativeUIController} from "../UI/controllers/NativeUIController";
import {defaultOptions} from "../UI/HTMLTooltip";
import {HTMLTooltipUIController} from "../UI/controllers/HTMLTooltipUIController";
import {OverlayUIController} from "../UI/controllers/OverlayUIController";
import {GetAlias} from "../deviceApiCalls/additionalDeviceApiCalls";

/**
 * @typedef {import('../deviceApiCalls/__generated__/validators-ts').StoreFormData} StoreFormData
 * @typedef {"macos-legacy" | "macos-modern" | "macos-overlay" | "ios" | "android" | "android" | "windows" | "windows-overlay" | "extension"} Ctx
 * @typedef {import('../deviceApiCalls/__generated__/validators-ts').GetAutofillDataRequest} GetAutofillDataRequest
 */

const TOOLTIP_TYPES = {
    EmailProtection: 'EmailProtection',
    EmailSignup: 'EmailSignup'
}


/**
 * @implements {GlobalConfigImpl}
 * @implements {FormExtensionPoints}
 * @implements {DeviceExtensionPoints}
 */
class InterfacePrototype {
    attempts = 0
    /** @type {import("../Form/Form").Form | null} */
    activeForm = null

    /** @type {number} */
    get initialSetupDelayMs() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.globalConfig.isDDGTestMode ? 0 : 300
            }
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension":
                break;

        }
        return 0
    }

    autopromptFired = false

    /** @type {PasswordGenerator} */
    passwordGenerator = new PasswordGenerator();

    /** @type {{privateAddress: string, personalAddress: string}} */
    #addresses = {
        privateAddress: '',
        personalAddress: ''
    }

    /** @type {GlobalConfig} */
    globalConfig;

    /** @type {import('../Scanner').Scanner} */
    scanner;

    /** @type {import("../UI/controllers/UIController.js").UIController | null} */
    uiController;

    /** @type {import("../../packages/device-api").DeviceApi} */
    deviceApi;

    /** @type {boolean} */
    isInitializationStarted;

    /** @type {Ctx} */
    ctx;

    /**
     * @param {Ctx} ctx
     * @param {GlobalConfig} config
     * @param {import("../../packages/device-api").DeviceApi} deviceApi
     * @param {Settings} settings
     */
    constructor(ctx, config, deviceApi, settings) {
        this.ctx = ctx
        this.globalConfig = config
        this.deviceApi = deviceApi
        this.settings = settings
        this.uiController = null
        this.scanner = createScanner(this, {
            initialDelay: this.initialSetupDelayMs
        })
        this.isInitializationStarted = false
    }

    async init() {
        const isEnabled = await this.isEnabled()
        if (!isEnabled) {
            console.log('!isEnabled');
            return
        }

        const handler = async () => {
            if (document.readyState === 'complete') {
                window.removeEventListener('load', handler)
                document.removeEventListener('readystatechange', handler)
                await this.startInit()
            }
        }
        if (document.readyState === 'complete') {
            await this.startInit()
        } else {
            window.addEventListener('load', handler)
            document.addEventListener('readystatechange', handler)
        }
    }

    /**
     * @returns {Promise<boolean>}
     */
    async isEnabled() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios":
            case "android":
                return autofillEnabled(this.globalConfig, processConfig)
            case "windows":
            case "windows-overlay":
                return true
            case "extension": {
                return new Promise(resolve => {
                    chrome.runtime.sendMessage(
                        {
                            registeredTempAutofillContentScript: true,
                            documentUrl: window.location.href
                        },
                        (response) => {
                            if (response && 'site' in response) {
                                resolve(isAutofillEnabledFromProcessedConfig(response))
                            }
                        }
                    )
                })
            }
            default:
                throw new Error('unreachable isEnabled ' + this.ctx)
        }
    }

    async startInit() {

        if (this.isInitializationStarted) return

        this.alreadyInitialized = true

        // done
        await this.settings.refresh()

        // done
        this.addDeviceListeners()

        await this.setupAutofill()

        this.uiController = this.createUIController()

        // this is the temporary measure to support windows whilst we still have 'setupAutofill'
        // eventually all interfaces will use this
        if (!this.isEnabledViaSettings()) {
            return
        }

        await this.setupSettingsPage()
        await this.postInit()

        if (this.settings.featureToggles.credentials_saving) {
            // initFormSubmissionsApi(this.scanner.forms)
        }
    }

    addDeviceListeners() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern": {
                if (this.settings.featureToggles.third_party_credentials_provider) {
                    if (this.globalConfig.hasModernWebkitAPI) {
                        Object.defineProperty(window, 'providerStatusUpdated', {
                            enumerable: false,
                            configurable: false,
                            writable: false,
                            value: (data) => {
                                this.providerStatusUpdated(data)
                            }
                        })
                    } else {
                        // On Catalina we poll the native layer
                        setTimeout(() => this._pollForUpdatesToCredentialsProvider(), 2000)
                    }
                }
                break;
            }
            case "windows-overlay":
            case "macos-overlay": {
                /**
                 * The native side will send a custom event 'mouseMove' to indicate
                 * that the HTMLTooltip should fake an element being focused.
                 *
                 * Note: There's no cleanup required here since the Overlay has a fresh
                 * page load every time it's opened.
                 */
                window.addEventListener('mouseMove', (event) => {
                    const activeTooltip = this.uiController?.getActiveTooltip?.()
                    activeTooltip?.focus(event.detail.x, event.detail.y)
                })
                break;
            }
            case "ios":
                break;
            case "android":
                break;
            case "windows":
                break;
            case "extension": {
                // Add contextual menu listeners
                let activeEl = null
                document.addEventListener('contextmenu', e => {
                    activeEl = e.target
                })

                chrome.runtime.onMessage.addListener((message, sender) => {
                    if (sender.id !== chrome.runtime.id) return

                    switch (message.type) {
                        case 'ddgUserReady':
                            this.resetAutofillUI(() => this.setupSettingsPage({shouldLog: true}))
                            break
                        case 'contextualAutofill':
                            setValue(activeEl, formatDuckAddress(message.alias), this.globalConfig)
                            activeEl.classList.add('ddg-autofilled')
                            this.refreshAlias()

                            // If the user changes the alias, remove the decoration
                            activeEl.addEventListener(
                                'input',
                                (e) => e.target.classList.remove('ddg-autofilled'),
                                {once: true}
                            )
                            break
                        default:
                            break
                    }
                })
                break;
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    async setupAutofill() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                const response = await this.deviceApi.request(createRequest('pmHandlerGetAutofillInitData'))
                this.storeLocalData(response.success)
                const {isAppSignedIn} = await this.deviceApi.request(createRequest('emailHandlerCheckAppSignedInStatus'))
                this._isDeviceSignedIn = Boolean(isAppSignedIn);
                if (this._isDeviceSignedIn) {
                    await this.getAddresses()
                }
                break;
            }
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay": {
                const response = await this.deviceApi.request(new GetAutofillInitDataCall(null))
                // @ts-ignore
                this.storeLocalData(response)
                break;
            }
            case "extension":
                return this.getAddresses()
            default:
                assertUnreachable(this.ctx)
        }
    }

    /**
     * Implementors should override this with a UI controller that suits
     * their platform.
     *
     * @returns {import("../UI/controllers/UIController.js").UIController}
     */
    createUIController() {
        switch (this.ctx) {
            case "macos-legacy": {
                const options = {
                    ...defaultOptions,
                    testMode: this.isTestMode()
                }
                return new HTMLTooltipUIController({
                    device: this,
                    tooltipKind: 'modern'
                }, options)
            }
            case "macos-modern": {
                /**
                 * If we get here, we're just a controller for an overlay
                 */
                return new OverlayUIController({
                    remove: async () => this.deviceApi.notify(createNotification('closeAutofillParent', {})),
                    show: async (details) => {
                        const applePayload = {
                            ...details.triggerContext,
                            serializedInputContext: details.serializedInputContext
                        }
                        this.deviceApi.notify(createNotification('showAutofillParent', applePayload))

                        // start listening for a result
                        const listener = new Promise((resolve) => {
                            // Prevent two timeouts from happening
                            // @ts-ignore
                            const poll = async () => {
                                clearTimeout(this.pollingTimeout)
                                const response = await this.deviceApi.request(createRequest('getSelectedCredentials'))
                                switch (response.type) {
                                    case 'none':
                                        // Parent hasn't got a selected credential yet
                                        // @ts-ignore
                                        this.pollingTimeout = setTimeout(() => {
                                            poll()
                                        }, 100)
                                        return
                                    case 'ok': {
                                        return resolve({data: response.data, configType: response.configType})
                                    }
                                    case 'stop':
                                        // Parent wants us to stop polling
                                        resolve(null)
                                        break
                                }
                            }
                            poll()
                        });
                        listener.then((response) => {
                            if (!response) {
                                return
                            }
                            this.selectedDetail(response.data, response.configType)
                        }).catch(e => {
                            console.error('unknown error', e)
                        })
                    }
                })
            }
            case "macos-overlay": {
                return new HTMLTooltipUIController({
                    tooltipKind: /** @type {const} */ ('modern'),
                    device: this
                }, {
                    wrapperClass: 'top-autofill',
                    tooltipPositionClass: () => '.wrapper { transform: none; }',
                    setSize: (details) => this.deviceApi.notify(createNotification('setSize', details)),
                    testMode: this.isTestMode()
                })
            }
            case "ios":
            case "android": {
                return new NativeUIController()
            }
            case "windows": {
                /**
                 * If we get here, we're just a controller for an overlay
                 */
                return new OverlayUIController({
                    remove: async () => {
                        if (this._abortController && !this._abortController.signal.aborted) {
                            this._abortController.abort()
                        }
                        this.deviceApi.notify(new CloseAutofillParentCall(null))
                    },
                    show: async (details) => {
                        const {mainType} = details
                        // prevent overlapping listeners
                        if (this._abortController && !this._abortController.signal.aborted) {
                            this._abortController.abort()
                        }
                        this._abortController = new AbortController()
                        this.deviceApi.request(new GetAutofillDataCall(details), {signal: this._abortController.signal})
                            .then(resp => {
                                if (!this.activeForm) {
                                    throw new Error('this.currentAttached was absent')
                                }
                                switch (resp.action) {
                                    case 'fill': {
                                        if (mainType in resp) {
                                            this.activeForm?.autofillData(resp[mainType], mainType)
                                        } else {
                                            throw new Error(`action: "fill" cannot occur because "${mainType}" was missing`)
                                        }
                                        break
                                    }
                                    case 'focus': {
                                        this.activeForm?.activeInput?.focus()
                                        break
                                    }
                                    case 'none': {
                                        // do nothing
                                        break
                                    }
                                    default: {
                                        if (this.globalConfig.isDDGTestMode) {
                                            console.warn('unhandled response', resp)
                                        }
                                    }
                                }
                                return this.deviceApi.notify(new CloseAutofillParentCall(null))
                            })
                            .catch(e => {
                                if (this.globalConfig.isDDGTestMode) {
                                    if (e.name === 'AbortError') {
                                        console.log('Promise Aborted')
                                    } else {
                                        console.error('Promise Rejected', e)
                                    }
                                }
                            })
                    }
                })
            }
            case "windows-overlay": {
                return new HTMLTooltipUIController({
                    tooltipKind: /** @type {const} */ ('modern'),
                    device: this
                }, {
                    wrapperClass: 'top-autofill',
                    tooltipPositionClass: () => '.wrapper { transform: none; }',
                    setSize: (details) => this.deviceApi.notify(new SetSizeCall(details)),
                    testMode: this.isTestMode(),
                    /**
                     * Note: This is needed because Mutation observer didn't support visibility checks on Windows
                     */
                    checkVisibility: false
                })
            }
            case "extension": {
                /** @type {import('../UI/HTMLTooltip.js').HTMLTooltipOptions} */
                const htmlTooltipOptions = {
                    ...defaultOptions,
                    css: `<link rel="stylesheet" href="${chrome.runtime.getURL('public/css/autofill.css')}" crossOrigin="anonymous">`,
                    testMode: this.isTestMode()
                }
                const tooltipKinds = {
                    [TOOLTIP_TYPES.EmailProtection]: 'legacy',
                    [TOOLTIP_TYPES.EmailSignup]: 'emailsignup'
                }
                const tooltipKind = tooltipKinds[this.getActiveTooltipType()] || tooltipKinds[TOOLTIP_TYPES.EmailProtection]

                return new HTMLTooltipUIController({tooltipKind, device: this}, htmlTooltipOptions)
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    getActiveTooltipType() {
        switch (this.ctx) {
            case "macos-legacy":
                break;
            case "macos-modern":
                break;
            case "macos-overlay":
                break;
            case "ios":
                break;
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                if (this.hasLocalAddresses) {
                    return TOOLTIP_TYPES.EmailProtection
                }

                if (this.settings.featureToggles.emailProtection_incontext_signup && this.settings.incontextSignupPermanentlyDismissed === false) {
                    return TOOLTIP_TYPES.EmailSignup
                }
                break
            }
            default:
                assertUnreachable(this.ctx)
        }

        return null
    }

    /** @type {AbortController|null} */
    _abortController = null;

    /** @type {any} */
    pollingTimeout = null;

    get hasLocalAddresses() {
        return !!(this.#addresses?.privateAddress && this.#addresses?.personalAddress)
    }

    getLocalAddresses() {
        return this.#addresses
    }

    storeLocalAddresses(addresses) {
        this.#addresses = addresses
        // When we get new duck addresses, add them to the identities list
        const identities = this.getLocalIdentities()
        const privateAddressIdentity = identities.find(({id}) => id === 'privateAddress')
        // If we had previously stored them, just update the private address
        if (privateAddressIdentity) {
            privateAddressIdentity.emailAddress = formatDuckAddress(addresses.privateAddress)
        } else {
            // Otherwise, add both addresses
            this.#data.identities = this.addDuckAddressesToIdentities(identities)
        }
    }

    /** @type { PMData } */
    #data = {
        credentials: [],
        creditCards: [],
        identities: [],
        topContextData: undefined
    }

    onIncontextSignup() {
        switch (this.ctx) {
            case "macos-legacy":
                break;
            case "macos-modern":
                break;
            case "macos-overlay":
                break;
            case "ios":
                break;
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return this.firePixel({pixelName: 'incontext_get_email_protection'})
            }
        }
    }

    onIncontextSignupDismissed() {
        switch (this.ctx) {
            case "macos-legacy":
                break;
            case "macos-modern":
                break;
            case "macos-overlay":
                break;
            case "ios":
                break;
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                // Check if the email signup tooltip has previously been dismissed.
                // If it has, make the dismissal persist and remove it from the page.
                // If it hasn't, set a flag for next time and just hide the tooltip.
                if (this.settings.incontextSignupInitiallyDismissed) {
                    this.settings.setIncontextSignupPermanentlyDismissed(true)
                    this.deviceApi.notify(new SetIncontextSignupPermanentlyDismissedAtCall({value: new Date().getTime()}))
                    this.removeAutofillUIFromPage()
                    this.firePixel({pixelName: 'incontext_dismiss_persisted'})
                } else {
                    this.settings.setIncontextSignupInitiallyDismissed(true)
                    this.deviceApi.notify(new SetIncontextSignupInitiallyDismissedAtCall({value: new Date().getTime()}))
                    this.removeTooltip()
                    this.firePixel({pixelName: 'incontext_dismiss_initial'})
                }
            }
        }
    }

    /**
     * @returns {import('../Form/matching').SupportedTypes}
     */
    getCurrentInputType() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                const topContextData = this.getTopContextData()
                return topContextData?.inputType
                    ? topContextData.inputType
                    : getInputType(this.activeForm?.activeInput)
            }
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension":
                break;

        }
        throw new Error('unreachable');
    }

    addDuckAddressesToIdentities(identities) {
        if (!this.hasLocalAddresses) return identities

        const newIdentities = []
        let {privateAddress, personalAddress} = this.getLocalAddresses()
        privateAddress = formatDuckAddress(privateAddress)
        personalAddress = formatDuckAddress(personalAddress)

        // Get the duck addresses in identities
        const duckEmailsInIdentities = identities.reduce(
            (duckEmails, {emailAddress: email}) =>
                email?.includes(ADDRESS_DOMAIN) ? duckEmails.concat(email) : duckEmails,
            []
        )

        // Only add the personal duck address to identities if the user hasn't
        // already manually added it
        if (!duckEmailsInIdentities.includes(personalAddress)) {
            newIdentities.push({
                id: 'personalAddress',
                emailAddress: personalAddress,
                title: 'Blocks email trackers'
            })
        }

        newIdentities.push({
            id: 'privateAddress',
            emailAddress: privateAddress,
            title: 'Blocks email trackers and hides your address'
        })

        return [...identities, ...newIdentities]
    }

    /**
     * Stores init data coming from the tooltipHandler
     * @param { InboundPMData } data
     */
    storeLocalData(data) {
        this.storeLocalCredentials(data.credentials)

        data.creditCards.forEach((cc) => delete cc.cardNumber && delete cc.cardSecurityCode)
        // Store the full name as a separate field to simplify autocomplete
        const updatedIdentities = data.identities.map((identity) => ({
            ...identity,
            fullName: formatFullName(identity)
        }))
        // Add addresses
        this.#data.identities = this.addDuckAddressesToIdentities(updatedIdentities)
        this.#data.creditCards = data.creditCards

        // Top autofill only
        if (data.serializedInputContext) {
            try {
                this.#data.topContextData = JSON.parse(data.serializedInputContext)
            } catch (e) {
                console.error(e)
                this.removeTooltip()
            }
        }
    }

    /**
     * Stores credentials locally
     * @param {CredentialsObject[]} credentials
     */
    storeLocalCredentials(credentials) {
        credentials.forEach((cred) => delete cred.password)
        this.#data.credentials = credentials
    }

    getTopContextData() {
        return this.#data.topContextData
    }

    getLocalCredentials() {
        return this.#data.credentials.map(cred => {
            const {password, ...rest} = cred
            return rest
        })
    }

    getLocalIdentities() {
        return this.#data.identities
    }

    /** @return {CreditCardObject[]} */
    getLocalCreditCards() {
        return this.#data.creditCards
    }

    /**
     * This is to aid the migration to all platforms using Settings.enabled.
     *
     * For now, Windows is the only platform that can be 'enabled' or 'disabled' via
     * the new Settings - which is why in that interface it has `return this.settings.enabled`
     *
     * Whilst we wait for other platforms to catch up, we offer this default implementation
     * of just returning true.
     *
     * @returns {boolean}
     */
    isEnabledViaSettings() {
        switch (this.ctx) {
            case "macos-legacy":
                break;
            case "macos-modern":
                break;
            case "macos-overlay":
                break;
            case "ios":
                break;
            case "android":
                break;
            case "windows":
            case "windows-overlay":
                return Boolean(this.settings.enabled)
            case "extension":
                break;

        }
        return true;
    }

    /**
     * overlay API helpers
     */
    ready = false;

    postInit() {

        const defaultPostInit = () => {
            const cleanup = this.scanner.init()
            this.addLogoutListener(() => {
                cleanup()
                if (this.globalConfig.isDDGDomain) {
                    notifyWebApp({deviceSignedIn: {value: false}})
                }
            })
        }

        const showImmediately = () => {
            const topContextData = this.getTopContextData()
            if (!topContextData) throw new Error('unreachable, topContextData should be available')

            // Provide dummy values
            const getPosition = () => {
                return {
                    x: 0,
                    y: 0,
                    height: 50,
                    width: 50
                }
            }

            // Create the tooltip, and set it as active
            const tooltip = this.uiController?.createTooltip?.(getPosition, topContextData)
            if (tooltip) {
                this.uiController?.setActiveTooltip?.(tooltip)
            }
        }

        switch (this.ctx) {
            case "macos-legacy":
                return defaultPostInit();
            case "macos-modern":
                return defaultPostInit();
            case "macos-overlay":
                // setup overlay API pieces
                showImmediately();
                return;
            case "ios":
                return defaultPostInit();
            case "android":
                return defaultPostInit();
            case "windows": {
                defaultPostInit();
                this.ready = true
                return;
            }
            case "windows-overlay": {
                showImmediately();
                return;
            }
            case "extension": {
                switch (this.getActiveTooltipType()) {
                    case TOOLTIP_TYPES.EmailProtection: {
                        this._scannerCleanup = this.scanner.init()
                        this.addLogoutListener(() => {
                            this.resetAutofillUI()
                            if (this.globalConfig.isDDGDomain) {
                                notifyWebApp({deviceSignedIn: {value: false}})
                            }
                        })

                        if (this.activeForm?.activeInput) {
                            this.attachTooltip(this.activeForm, this.activeForm?.activeInput, null, 'postSignup')
                        }

                        break
                    }
                    case TOOLTIP_TYPES.EmailSignup: {
                        this._scannerCleanup = this.scanner.init()
                        break
                    }
                    default: {
                        // Don't do anyhing if we don't have a tooltip to show
                        break
                    }
                }
                break;
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    isTestMode() {
        return this.globalConfig.isDDGTestMode
    }

    /**
     * This indicates an item was selected, and we should try to autofill
     *
     * Note: When we're in a top-frame scenario, like on like macOS & Windows in the webview,
     * this method gets overridden {@see WindowsOverlayDeviceInterface} {@see AppleOverlayDeviceInterface}
     *
     * @param {IdentityObject|CreditCardObject|CredentialsObject|{email:string, id: string}} data
     * @param {string} type
     */
    async selectedDetail(data, type) {
        const defaultSelectedMethod = () => {
            const form = this.activeForm
            if (!form) {
                return
            }
            if (data.id === 'privateAddress') {
                this.refreshAlias().catch(console.error)
            }
            if (type === 'email' && 'email' in data) {
                form.autofillEmail(data.email)
            } else {
                form.autofillData(data, type)
            }
            this.removeTooltip()
        }

        const overlaySelected = async () => {
            let detailsEntries = Object.entries(data).map(([key, value]) => {
                return [key, String(value)]
            })
            const entries = Object.fromEntries(detailsEntries)
            /** @link {import("../deviceApiCalls/schemas/getAutofillData.result.json")} */
            await this.deviceApi.notify(new SelectedDetailCall({data: entries, configType: type}))
        }

        switch (this.ctx) {
            case "macos-legacy":
                return defaultSelectedMethod()
            case "macos-modern":
                return defaultSelectedMethod()
            case "macos-overlay": {
                return overlaySelected();
            }
            case "ios":
                return defaultSelectedMethod()
            case "android":
                return defaultSelectedMethod()
            case "windows":
                return defaultSelectedMethod()
            case "windows-overlay": {
                return overlaySelected();
            }
            case "extension":
                return defaultSelectedMethod()
            default:
                assertUnreachable(this.ctx)
        }
    }

    /**
     * Before the DataWebTooltip opens, we collect the data based on the config.type
     * @param {InputTypeConfigs} config
     * @param {import('../Form/matching').SupportedTypes} inputType
     * @param {TopContextData} [data]
     * @returns {(CredentialsObject|CreditCardObject|IdentityObject)[]}
     */
    dataForAutofill(config, inputType, data) {
        const subtype = getSubtypeFromType(inputType)
        if (config.type === 'identities') {
            return this.getLocalIdentities().filter(identity => !!identity[subtype])
        }
        if (config.type === 'creditCards') {
            return this.getLocalCreditCards()
        }
        if (config.type === 'credentials') {
            if (data) {
                if (Array.isArray(data.credentials) && data.credentials.length > 0) {
                    return data.credentials
                } else {
                    return this.getLocalCredentials()
                }
            }
        }
        return []
    }

    /**
     * @param {import("../Form/Form").Form} form
     * @param {HTMLInputElement} input
     * @param {{ x: number; y: number; } | null} click
     * @param {import('../deviceApiCalls/__generated__/validators-ts').GetAutofillDataRequest['trigger']} trigger
     */
    attachTooltip(form, input, click, trigger = 'userInitiated') {
        console.log('attachTooltip', form, input)
        // Avoid flashing tooltip from background tabs on macOS
        if (document.visibilityState !== 'visible' && trigger !== 'postSignup') return
        // Only autoprompt on mobile devices
        if (trigger === 'autoprompt' && !this.globalConfig.isMobileApp) return
        // Only fire autoprompt once
        if (trigger === 'autoprompt' && this.autopromptFired) return

        form.activeInput = input
        this.activeForm = form
        const inputType = getInputType(input)

        /** @type {PosFn} */
        const getPosition = () => {
            // In extensions, the tooltip is centered on the Dax icon
            const alignLeft = this.globalConfig.isApp || this.globalConfig.isWindows
            return alignLeft ? input.getBoundingClientRect() : getDaxBoundingBox(input)
        }

        // todo: this will be migrated to use NativeUIController soon
        if (this.globalConfig.isMobileApp && inputType === 'identities.emailAddress') {
            this.getAlias().then((alias) => {
                if (alias) form.autofillEmail(alias)
                else form.activeInput?.focus()
            })
            return
        }

        /** @type {TopContextData} */
        const topContextData = {
            inputType
        }

        // Allow features to append/change top context data
        // for example, generated passwords may get appended here
        const processedTopContext = this.preAttachTooltip(topContextData, input, form)

        this.uiController?.attach({
            input,
            form,
            click,
            getPosition,
            topContextData: processedTopContext,
            device: this,
            trigger
        })

        if (trigger === 'autoprompt') {
            this.autopromptFired = true
        }
    }

    /**
     * When an item was selected, we then call back to the device
     * to fetch the full suite of data needed to complete the autofill
     *
     * @param {import('../Form/matching').SupportedTypes} inputType
     * @param {(CreditCardObject|IdentityObject|CredentialsObject)[]} items
     * @param {CreditCardObject['id']|IdentityObject['id']|CredentialsObject['id']} id
     */
    onSelect(inputType, items, id) {
        id = String(id)
        const mainType = getMainTypeFromType(inputType)
        const subtype = getSubtypeFromType(inputType)

        if (id === PROVIDER_LOCKED) {
            return this.askToUnlockProvider()
        }

        const matchingData = items.find(item => String(item.id) === id)
        if (!matchingData) throw new Error('unreachable (fatal)')

        const dataPromise = (() => {
            switch (mainType) {
                case 'creditCards':
                    return this.getAutofillCreditCard(id)
                case 'identities':
                    return this.getAutofillIdentity(id)
                case 'credentials': {
                    if (AUTOGENERATED_KEY in matchingData) {
                        return Promise.resolve({success: matchingData})
                    }
                    return this.getAutofillCredentials(id)
                }
                default:
                    throw new Error('unreachable!')
            }
        })()

        // wait for the data back from the device
        dataPromise.then(response => {
            if (response) {
                const data = response.success || response
                if (mainType === 'identities') {
                    this.firePixel({pixelName: 'autofill_identity', params: {fieldType: subtype}})
                    switch (id) {
                        case 'personalAddress':
                            this.firePixel({pixelName: 'autofill_personal_address'})
                            break
                        case 'privateAddress':
                            this.firePixel({pixelName: 'autofill_private_address'})
                            break
                        default:
                            // Also fire pixel when filling an identity with the personal duck address from an email field
                            const checks = [
                                subtype === 'emailAddress',
                                this.hasLocalAddresses,
                                data?.emailAddress === formatDuckAddress(this.#addresses.personalAddress)
                            ]
                            if (checks.every(Boolean)) {
                                this.firePixel({pixelName: 'autofill_personal_address'})
                            }
                            break
                    }
                }
                // some platforms do not include a `success` object, why?
                return this.selectedDetail(data, mainType)
            } else {
                return Promise.reject(new Error('none-success response'))
            }
        }).catch(e => {
            console.error(e)
            return this.removeTooltip()
        })
    }

    async askToUnlockProvider() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay": {
                const response = await this.deviceApi.request(new AskToUnlockProviderCall(null))
                this.providerStatusUpdated(response)
                return;
            }
            case "ios":
                break;
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension":
                break;
            default:
                assertUnreachable(this.ctx)
        }
    }

    isTooltipActive() {
        return this.uiController?.isActive?.() ?? false
    }

    removeTooltip() {
        return this.uiController?.removeTooltip?.('interface')
    }

    async setupSettingsPage({shouldLog} = {shouldLog: false}) {
        if (!this.globalConfig.isDDGDomain) {
            return
        }

        notifyWebApp({isApp: this.globalConfig.isApp})

        if (this.isDeviceSignedIn()) {
            let userData
            try {
                userData = await this.getUserData()
            } catch (e) {
            }

            let capabilities
            try {
                capabilities = await this.getEmailProtectionCapabilities()
            } catch (e) {
            }

            // Set up listener for web app actions
            window.addEventListener('message', (e) => {
                if (this.globalConfig.isDDGDomain && e.data.removeUserData) {
                    this.removeUserData()
                }
            })

            const hasUserData = userData && !userData.error && Object.entries(userData).length > 0
            notifyWebApp({
                deviceSignedIn: {
                    value: true,
                    shouldLog,
                    userData: hasUserData ? userData : undefined,
                    capabilities
                }
            })
        } else {
            this.trySigningIn()
        }
    }

    /** @returns {Promise<EmailAddresses | null>} */
    async getAddresses() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay": {
                const {addresses} = await this.deviceApi.request(createRequest('emailHandlerGetAddresses'))
                this.storeLocalAddresses(addresses)
                return addresses
            }
            case "ios": {
                return this.getAlias();
            }
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return new Promise(resolve => chrome.runtime.sendMessage(
                    {getAddresses: true},
                    (data) => {
                        this.storeLocalAddresses(data)
                        return resolve(data)
                    }
                ))
            }
            default:
                assertUnreachable(this.ctx)
        }
        return null
    }

    /** @returns {Promise<null|Record<any,any>>} */
    async getUserData() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.deviceApi.request(createRequest('emailHandlerGetUserData'))
            }
            case "android": {
                let userData = null

                try {
                    userData = JSON.parse(window.EmailInterface.getUserData())
                } catch (e) {
                    if (this.globalConfig.isDDGTestMode) {
                        console.error(e)
                    }
                }

                return Promise.resolve(userData)
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return new Promise(resolve => chrome.runtime.sendMessage(
                    {getUserData: true},
                    (data) => resolve(data)
                ))
            }
            default:
                assertUnreachable(this.ctx)
        }
        return null;
    }

    /**
     */
    removeUserData() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.deviceApi.notify(createNotification('emailHandlerRemoveToken'))
            }
            case "android": {
                try {
                    window.EmailInterface.removeCredentials()
                } catch (e) {
                    if (this.globalConfig.isDDGTestMode) {
                        console.error(e)
                    }
                }
                break;
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return chrome.runtime.sendMessage({removeUserData: true})
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    /** @returns {Promise<null|Record<string,boolean>>} */
    async getEmailProtectionCapabilities() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.deviceApi.request(createRequest('emailHandlerGetCapabilities'))
            }
            case "android": {
                let deviceCapabilities = null

                try {
                    deviceCapabilities = JSON.parse(window.EmailInterface.getDeviceCapabilities())
                } catch (e) {
                    if (this.globalConfig.isDDGTestMode) {
                        console.error(e)
                    }
                }

                return Promise.resolve(deviceCapabilities)
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return new Promise(resolve => chrome.runtime.sendMessage(
                    {getEmailProtectionCapabilities: true},
                    (data) => resolve(data)
                ))
            }
            default:
                assertUnreachable(this.ctx)
        }
        return null
    }

    async refreshAlias() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                await this.deviceApi.notify(createNotification('emailHandlerRefreshAlias'))
                switch (this.ctx) {
                    case "macos-legacy":
                    case "macos-modern":
                    case "macos-overlay": {
                        this.getAddresses().catch(console.error)
                        break;
                    }
                    case "ios":
                        break;
                }
                break;
            }
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return chrome.runtime.sendMessage(
                    {refreshAlias: true},
                    (addresses) => this.storeLocalAddresses(addresses)
                )
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    async trySigningIn() {
        switch (this.ctx) {
            case "macos-legacy":
                break;
            case "macos-modern":
                break;
            case "macos-overlay":
                break;
            case "ios":
                break;
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                if (this.globalConfig.isDDGDomain) {
                    const data = await sendAndWaitForAnswer(SIGN_IN_MSG, 'addUserData')
                    this.storeUserData(data)
                }
                return
            }
            default:
                assertUnreachable(this.ctx)
        }

        if (this.globalConfig.isDDGDomain) {
            if (this.attempts < 10) {
                this.attempts++
                const data = await sendAndWaitForAnswer(SIGN_IN_MSG, 'addUserData')
                // This call doesn't send a response, so we can't know if it succeeded
                this.storeUserData(data)

                await this.setupAutofill()
                await this.settings.refresh()
                await this.setupSettingsPage({shouldLog: true})
                await this.postInit()
            } else {
                console.warn('max attempts reached, bailing')
            }
        }
    }

    /**
     * @param {object} data
     * @param {object} data.addUserData
     * @param {string} data.addUserData.token
     * @param {string} data.addUserData.userName
     * @param {string} data.addUserData.cohort
     */
    storeUserData(data) {
        const {addUserData: {token, userName, cohort}} = data;
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.deviceApi.notify(createNotification('emailHandlerStoreToken', {
                    token,
                    username: userName,
                    cohort
                }))
            }
            case "android": {
                return window.EmailInterface.storeCredentials(token, userName, cohort)
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return chrome.runtime.sendMessage(data)
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    async _pollForUpdatesToCredentialsProvider() {
        try {
            const response = await this.deviceApi.request(new CheckCredentialsProviderStatusCall(null))
            if (response.availableInputTypes.credentialsProviderStatus !== this.settings.availableInputTypes.credentialsProviderStatus) {
                this.providerStatusUpdated(response)
            }
            setTimeout(() => this._pollForUpdatesToCredentialsProvider(), 2000)
        } catch (e) {
            if (this.globalConfig.isDDGTestMode) {
                console.log('isDDGTestMode: _pollForUpdatesToCredentialsProvider: ❌', e)
            }
        }
    }

    async resetAutofillUI(callback) {
        this.removeAutofillUIFromPage()

        // Start the setup process again
        await this.settings.refresh()
        await this.setupAutofill()

        if (callback) await callback()

        this.uiController = this.createUIController()
        await this.postInit()

    }

    removeAutofillUIFromPage() {
        this.uiController?.destroy()
        this._scannerCleanup?.()
    }

    /**
     * Called by the native layer on all tabs when the provider status is updated
     * @param {import("../deviceApiCalls/__generated__/validators-ts").ProviderStatusUpdated} data
     */
    providerStatusUpdated(data) {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern": {
                try {
                    const {credentials, availableInputTypes} = validate(data, providerStatusUpdatedSchema)

                    // Update local settings and data
                    this.settings.setAvailableInputTypes(availableInputTypes)
                    this.storeLocalCredentials(credentials)

                    // rerender the tooltip
                    this.uiController?.updateItems(credentials)
                    // If the tooltip is open on an autofill type that's not available, close it
                    const currentInputSubtype = getSubtypeFromType(this.getCurrentInputType())
                    if (!availableInputTypes.credentials?.[currentInputSubtype]) {
                        this.removeTooltip()
                    }
                    // Redecorate fields according to the new types
                    this.scanner.forms.forEach(form => form.recategorizeAllInputs())
                } catch (e) {
                    if (this.globalConfig.isDDGTestMode) {
                        console.log('isDDGTestMode: providerStatusUpdated error: ❌', e)
                    }
                }
                break;
            }
            case "macos-overlay": {
                const {credentials, availableInputTypes} = validate(data, providerStatusUpdatedSchema)

                // Update local settings and data
                this.settings.setAvailableInputTypes(availableInputTypes)
                this.storeLocalCredentials(credentials)

                // rerender the tooltip
                this.uiController?.updateItems(credentials)
                break;
            }
            case "ios":
            case "android":
            case "windows":
            case "windows-overlay":
            case "extension":
            default: {
                throw new Error('unreachable')
            }
        }
    }

    /** @param {() => void} handler */
    addLogoutListener(handler) {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                // Only deal with logging out if we're in the email web app
                if (!this.globalConfig.isDDGDomain) return

                window.addEventListener('message', (e) => {
                    if (this.globalConfig.isDDGDomain && e.data.emailProtectionSignedOut) {
                        handler()
                    }
                })
                return;
            }
            case "android": {
                // Only deal with logging out if we're in the email web app
                if (!this.globalConfig.isDDGDomain) return

                window.addEventListener('message', (e) => {
                    if (this.globalConfig.isDDGDomain && e.data.emailProtectionSignedOut) {
                        handler()
                    }
                })
                return;
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                // Make sure there's only one log out listener attached by removing the
                // previous logout listener first, if it exists.
                if (this._logoutListenerHandler) {
                    chrome.runtime.onMessage.removeListener(this._logoutListenerHandler)
                }

                // Cleanup on logout events
                this._logoutListenerHandler = (message, sender) => {
                    if (sender.id === chrome.runtime.id && message.type === 'logout') {
                        handler()
                    }
                }
                chrome.runtime.onMessage.addListener(this._logoutListenerHandler)
            }
        }
    }

    /**
     * Boolean
     * @returns {Promise<boolean>}
     */
    _isDeviceSignedIn = false;

    isDeviceSignedIn() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this._isDeviceSignedIn;
            }
            case "android": {
                // on DDG domains, always check via `window.EmailInterface.isSignedIn()`
                if (this.globalConfig.isDDGDomain) {
                    return window.EmailInterface.isSignedIn() === 'true'
                }

                // on non-DDG domains, where `availableInputTypes.email` is present, use it
                if (typeof this.globalConfig.availableInputTypes?.email === 'boolean') {
                    return this.globalConfig.availableInputTypes.email
                }

                // ...on other domains we assume true because the script wouldn't exist otherwise
                return true
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension": {
                return this.hasLocalAddresses
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    /**
     * @returns {Promise<*>}
     */
    async getAlias() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                const {alias} = await this.deviceApi.request(new GetAlias({
                    requiresUserPermission: !this.globalConfig.isApp,
                    shouldConsumeAliasIfProvided: !this.globalConfig.isApp
                }))
                return formatDuckAddress(alias)
            }
            case "android": {
                const {alias} = await sendAndWaitForAnswer(() => {
                    return window.EmailInterface.showTooltip()
                }, 'getAliasResponse')
                return alias
            }
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension":
                break;
            default:
                assertUnreachable(this.ctx)
        }
    }

    /**
     * Gets credentials ready for autofill
     * @param {CredentialsObject['id']} id - the credential id
     * @returns {Promise<CredentialsObject|{success:CredentialsObject}>}
     */
    async getAutofillCredentials(id) {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.deviceApi.request(createRequest('pmHandlerGetAutofillCredentials', {id}))
            }
            case "android":
                break;
            case "windows":
                break;
            case "windows-overlay":
                break;
            case "extension":
                break;

        }
        return this.deviceApi.request(new GetAutofillCredentialsCall({id: String(id)}))
    }

    /**
     * Gets a single complete credit card obj once the user requests it
     * @param {CreditCardObject['id']} id
     * @returns {APIResponse<CreditCardObject>}
     */
    async getAutofillCreditCard(id) {
        return this.deviceApi.request(createRequest('pmHandlerGetCreditCard', {id}))
    }

    /**
     * @param {IdentityObject['id']} id
     * @returns {Promise<{success: IdentityObject|undefined}>}
     */
    async getAutofillIdentity(id) {
        const identity = this.getLocalIdentities().find(({id: identityId}) => `${identityId}` === `${id}`)
        return Promise.resolve({success: identity})
    }

    /** @param {StoreFormData} values */
    storeFormData(values) {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.deviceApi.notify(createNotification('pmHandlerStoreData', values))
            }
            case "android":
            case "windows":
            case "windows-overlay": {
                return this.deviceApi.notify(new StoreFormDataCall(values))
            }
            case "extension":
                break;
            default:
                assertUnreachable(this.ctx)
        }
    }

    /**
     * `preAttachTooltip` happens just before a tooltip is show - features may want to append some data
     * at this point.
     *
     * For example, if password generation is enabled, this will generate
     * a password and send it to the tooltip as though it were a stored credential.
     *
     * @param {TopContextData} topContextData
     * @param {HTMLInputElement} input
     * @param {{isSignup: boolean|null}} form
     */
    preAttachTooltip(topContextData, input, form) {
        // A list of checks to determine if we need to generate a password
        const checks = [
            topContextData.inputType === 'credentials.password',
            this.settings.featureToggles.password_generation,
            form.isSignup
        ]

        // if all checks pass, generate and save a password
        if (checks.every(Boolean)) {
            const password = this.passwordGenerator.generate({
                input: input.getAttribute('passwordrules'),
                domain: window.location.hostname
            })

            // append the new credential to the topContextData so that the top autofill can display it
            topContextData.credentials = [fromPassword(password)]
        }

        return topContextData
    }

    /**
     * `postAutofill` gives features an opportunity to perform an action directly
     * following an autofill.
     *
     * For example, if a generated password was used, we want to fire a save event.
     *
     * @param {IdentityObject|CreditCardObject|CredentialsObject} data
     * @param {SupportedMainTypes} dataType
     * @param {import("../Form/Form").Form} formObj
     */
    postAutofill(data, dataType, formObj) {
        if (AUTOGENERATED_KEY in data && 'password' in data) {
            const formValues = formObj.getValues()
            if (formValues.credentials?.password === data.password) {
                const withAutoGeneratedFlag = appendGeneratedId(formValues, data.password)
                this.storeFormData(withAutoGeneratedFlag)
            }
        }

        if (dataType === 'credentials' && this.settings.globalConfig.isMobileApp) {
            formObj.attemptSubmissionIfNeeded()
        }
    }

    /**
     * `postSubmit` gives features a one-time-only opportunity to perform an
     * action directly after a form submission was observed.
     *
     * Mostly this is about storing data from the form submission, but it can
     * also be used like in the case of Password generation, to append additional
     * data before it's sent to be saved.
     *
     * @param {DataStorageObject} values
     * @param {import("../Form/Form").Form} form
     */
    postSubmit(values, form) {
        if (!form.form) return
        if (!form.hasValues(values)) return
        const checks = [
            form.shouldPromptToStoreData,
            this.passwordGenerator.generated
        ]

        if (checks.some(Boolean)) {
            const withAutoGeneratedFlag = appendGeneratedId(values, this.passwordGenerator.password)
            this.storeFormData(withAutoGeneratedFlag)
        }
    }

    /**
     * Sends a pixel to be fired on the client side
     * @param {import('../deviceApiCalls/__generated__/validators-ts').SendJSPixelParams} pixelParams
     */
    firePixel(pixelParams) {
        this.deviceApi.notify(new SendJSPixelCall(pixelParams))
    }

    /**
     * This serves as a single place to create a default instance
     * of InterfacePrototype that can be useful in testing scenarios
     * @returns {InterfacePrototype}
     */
    static default() {
        const globalConfig = createGlobalConfig()
        const transport = createTransport('macos-legacy', globalConfig)
        const deviceApi = new DeviceApi(transport)
        const settings = Settings.default(globalConfig, deviceApi)
        return new InterfacePrototype('macos-legacy', globalConfig, deviceApi, settings)
    }
}

export default InterfacePrototype

/**
 * @param {never} x
 * @returns {never}
 */
function assertUnreachable(x) {
    console.log(x)
    throw new Error("Didn't expect to get here");
}
