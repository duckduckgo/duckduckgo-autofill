import {
    autofillEnabled,
    isAutofillEnabledFromProcessedConfig
} from '../autofill-utils.js'

import {fromPassword, appendGeneratedId, AUTOGENERATED_KEY} from '../InputTypes/Credentials.js'
import {createScanner} from '../Scanner.js'
import {createGlobalConfig} from '../config.js'
import {createTransport} from '../deviceApiCalls/transports/transports.js'
import {Settings} from '../Settings.js'
import {DeviceApi} from '../../packages/device-api/index.js'
import {
    SendJSPixelCall,
} from '../deviceApiCalls/__generated__/deviceApiCalls.js'
import {initFormSubmissionsApi} from './initFormSubmissionsApi.js'
import {processConfig} from "@duckduckgo/content-scope-scripts/src/apple-utils";
import {LocalData} from "../features/local-data";
import {PasswordGenerator} from "../features/password-generator.js";
import {BitwardenIntegration} from "../features/bitwarden-integration";
import {EmailProtection} from "../features/email-protection";
import {FormFilling} from "../features/form-filling";
import {IncontextSignup} from "../features/incontext-signup";
import {RemoteData} from "../features/remote-data";
import {UIController} from "../features/ui-controller";

/**
 * @typedef {import('../deviceApiCalls/__generated__/validators-ts').StoreFormData} StoreFormData
 * @typedef {"macos-legacy" | "macos-modern" | "macos-overlay" | "ios" | "android" | "android" | "windows" | "windows-overlay" | "extension"} Ctx
 * @typedef {import('../deviceApiCalls/__generated__/validators-ts').GetAutofillDataRequest} GetAutofillDataRequest
 */

const TOOLTIP_TYPES = {
    EmailProtection: 'EmailProtection',
    EmailSignup: 'EmailSignup'
}

/**
 * @implements {GlobalConfigImpl}
 * @implements {FormExtensionPoints}
 * @implements {DeviceExtensionPoints}
 */
class InterfacePrototype {
    /** @type {number} */
    get initialSetupDelayMs() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios": {
                return this.globalConfig.isDDGTestMode ? 0 : 300
            }
            case "android":
            case "windows":
            case "windows-overlay":
            case "extension":
                break;

        }
        return 0
    }

    /** @type {boolean} */
    isInitializationStarted;

    /**
     * @param {Ctx} ctx
     * @param {GlobalConfig} config
     * @param {import("../../packages/device-api").DeviceApi} deviceApi
     * @param {Settings} settings
     */
    constructor(ctx, config, deviceApi, settings) {
        this.ctx = ctx
        this.globalConfig = config
        this.deviceApi = deviceApi
        this.settings = settings

        this.localData = new LocalData();
        this.remoteData = new RemoteData(this);
        this.passwordGenerator = new PasswordGenerator();
        this.bitwarden = new BitwardenIntegration(this);
        this.emailProtection = new EmailProtection(this);
        this.formFilling = new FormFilling(this);
        this.incontextSignup = new IncontextSignup(this);
        this.uiController = new UIController(this);

        this.scanner = createScanner(this, {
            initialDelay: this.initialSetupDelayMs
        })
        this.isInitializationStarted = false
    }

    async init() {
        const isEnabled = await this.isEnabled()
        if (!isEnabled) {
            console.log('!isEnabled');
            return
        }

        const handler = async () => {
            if (document.readyState === 'complete') {
                window.removeEventListener('load', handler)
                document.removeEventListener('readystatechange', handler)
                await this.startInit()
            }
        }
        if (document.readyState === 'complete') {
            await this.startInit()
        } else {
            window.addEventListener('load', handler)
            document.addEventListener('readystatechange', handler)
        }
    }

    /**
     * @returns {Promise<boolean>}
     */
    async isEnabled() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios":
            case "android":
                return autofillEnabled(this.globalConfig, processConfig)
            case "windows":
            case "windows-overlay":
                return true
            case "extension": {
                return new Promise(resolve => {
                    chrome.runtime.sendMessage(
                        {
                            registeredTempAutofillContentScript: true,
                            documentUrl: window.location.href
                        },
                        (response) => {
                            if (response && 'site' in response) {
                                resolve(isAutofillEnabledFromProcessedConfig(response))
                            }
                        }
                    )
                })
            }
            default:
                throw new Error('unreachable isEnabled ' + this.ctx)
        }
    }

    async startInit() {

        if (this.isInitializationStarted) return

        this.alreadyInitialized = true

        // done
        await this.settings.refresh()

        // done
        this.addDeviceListeners()

        // init features
        this.localData.init();
        this.remoteData.init();

        if (this.settings.featureToggles.password_generation) {
            this.passwordGenerator.init();
        }

        if (this.settings.featureToggles.third_party_credentials_provider) {
            this.bitwarden.init();
        }

        if (this.settings.featureToggles.emailProtection) {
            await this.emailProtection.init();
            await this.emailProtection.setupSettingsPage()
        }

        if (this.settings.featureToggles.emailProtection_incontext_signup) {
            this.incontextSignup.init();
        }

        await this.remoteData.refresh()

        this.uiController.init();

        // this is the temporary measure to support windows whilst we still have 'setupAutofill'
        // eventually all interfaces will use this
        if (!this.isEnabledViaSettings()) {
            return
        }

        await this.postInit()

        if (this.settings.featureToggles.credentials_saving) {
            initFormSubmissionsApi(this.scanner.forms)
        }
    }

    addDeviceListeners() {
        switch (this.ctx) {
            case "windows-overlay":
            case "macos-overlay": {
                /**
                 * The native side will send a custom event 'mouseMove' to indicate
                 * that the HTMLTooltip should fake an element being focused.
                 *
                 * Note: There's no cleanup required here since the Overlay has a fresh
                 * page load every time it's opened.
                 */
                window.addEventListener('mouseMove', (event) => {
                    const activeTooltip = this.uiController?.controller?.getActiveTooltip?.()
                    activeTooltip?.focus(event.detail.x, event.detail.y)
                })
                break;
            }
            case "macos-legacy":
            case "macos-modern":
            case "ios":
            case "android":
            case "windows":
            case "extension":
                break;
            default:
                assertUnreachable(this.ctx)
        }
    }

    getActiveTooltipType() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios":
            case "android":
            case "windows":
            case "windows-overlay":
                break;
            case "extension": {
                if (this.localData.hasLocalAddresses) {
                    return TOOLTIP_TYPES.EmailProtection
                }

                if (this.settings.featureToggles.emailProtection_incontext_signup && this.settings.incontextSignupPermanentlyDismissed === false) {
                    return TOOLTIP_TYPES.EmailSignup
                }
                break
            }
            default:
                assertUnreachable(this.ctx)
        }

        return null
    }

    /** @type {AbortController|null} */
    _abortController = null;

    /** @type {any} */
    pollingTimeout = null;

    /**
     * This is to aid the migration to all platforms using Settings.enabled.
     *
     * For now, Windows is the only platform that can be 'enabled' or 'disabled' via
     * the new Settings - which is why in that interface it has `return this.settings.enabled`
     *
     * Whilst we wait for other platforms to catch up, we offer this default implementation
     * of just returning true.
     *
     * @returns {boolean}
     */
    isEnabledViaSettings() {
        switch (this.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "macos-overlay":
            case "ios":
            case "android":
            case "extension":
                break;
            case "windows":
            case "windows-overlay":
                return Boolean(this.settings.enabled)

        }
        return true;
    }

    /**
     * overlay API helpers
     */
    ready = false;

    postInit() {

        switch (this.ctx) {
            case "ios":
            case "android":
            case "macos-legacy":
            case "macos-modern":
            case "windows": {
                this._scannerCleanup = this.scanner.init()
                this.emailProtection.postInit()
                this.ready = true
                return;
            }
            // show immediately inside overlays
            case "macos-overlay":
            case "windows-overlay": {
                const topContextData = this.localData.getTopContextData()
                if (!topContextData) throw new Error('unreachable, topContextData should be available')

                // Provide dummy values
                const getPosition = () => {
                    return {
                        x: 0,
                        y: 0,
                        height: 50,
                        width: 50
                    }
                }

                // Create the tooltip, and set it as active
                const tooltip = this.uiController?.controller?.createTooltip?.(getPosition, topContextData)
                if (tooltip) {
                    this.uiController?.controller?.setActiveTooltip?.(tooltip)
                }
                return;
            }
            case "extension": {
                switch (this.getActiveTooltipType()) {
                    case TOOLTIP_TYPES.EmailProtection: {
                        this._scannerCleanup = this.scanner.init()

                        if (this.uiController.activeForm?.activeInput) {
                            this.uiController.attachTooltip(this.uiController.activeForm, this.uiController.activeForm?.activeInput, null, 'postSignup')
                        }

                        break
                    }
                    case TOOLTIP_TYPES.EmailSignup: {
                        this._scannerCleanup = this.scanner.init()
                        break
                    }
                    default: {
                        // Don't do anyhing if we don't have a tooltip to show
                        break
                    }
                }
                break;
            }
            default:
                assertUnreachable(this.ctx)
        }
    }

    isTestMode() {
        return this.globalConfig.isDDGTestMode
    }

    isTooltipActive() {
        return this.uiController?.controller?.isActive?.() ?? false
    }

    /**
     * @param {string} reason
     * @returns {*}
     */
    removeTooltip(reason) {
        console.log('InterfacePrototype.removeTooltip', reason);
        return this.uiController?.controller?.removeTooltip?.('interface')
    }

    async resetAutofillUI(callback) {
        this.removeAutofillUIFromPage()

        // Start the setup process again
        await this.settings.refresh()
        await this.remoteData.refresh()

        if (callback) await callback()

        this.uiController?.init()
        await this.postInit()

    }

    removeAutofillUIFromPage() {
        this.uiController?.controller?.destroy()
        this._scannerCleanup?.()
    }

    /**
     * `preAttachTooltip` happens just before a tooltip is show - features may want to append some data
     * at this point.
     *
     * For example, if password generation is enabled, this will generate
     * a password and send it to the tooltip as though it were a stored credential.
     *
     * @param {TopContextData} topContextData
     * @param {HTMLInputElement} input
     * @param {{isSignup: boolean|null}} form
     */
    preAttachTooltip(topContextData, input, form) {
        // A list of checks to determine if we need to generate a password
        const checks = [
            topContextData.inputType === 'credentials.password',
            this.settings.featureToggles.password_generation,
            form.isSignup
        ]

        // if all checks pass, generate and save a password
        if (checks.every(Boolean)) {
            const password = this.passwordGenerator.generate({
                input: input.getAttribute('passwordrules'),
                domain: window.location.hostname
            })

            // append the new credential to the topContextData so that the top autofill can display it
            topContextData.credentials = [fromPassword(password)]
        }

        return topContextData
    }

    /**
     * `postAutofill` gives features an opportunity to perform an action directly
     * following an autofill.
     *
     * For example, if a generated password was used, we want to fire a save event.
     *
     * @param {IdentityObject|CreditCardObject|CredentialsObject} data
     * @param {SupportedMainTypes} dataType
     * @param {import("../Form/Form").Form} formObj
     */
    postAutofill(data, dataType, formObj) {
        if (AUTOGENERATED_KEY in data && 'password' in data) {
            const formValues = formObj.getValues()
            if (formValues.credentials?.password === data.password) {
                const withAutoGeneratedFlag = appendGeneratedId(formValues, data.password)
                this.remoteData.storeFormData(withAutoGeneratedFlag)
            }
        }

        if (dataType === 'credentials' && this.settings.globalConfig.isMobileApp) {
            formObj.attemptSubmissionIfNeeded()
        }
    }

    /**
     * `postSubmit` gives features a one-time-only opportunity to perform an
     * action directly after a form submission was observed.
     *
     * Mostly this is about storing data from the form submission, but it can
     * also be used like in the case of Password generation, to append additional
     * data before it's sent to be saved.
     *
     * @param {DataStorageObject} values
     * @param {import("../Form/Form").Form} form
     */
    postSubmit(values, form) {
        if (!form.form) return
        if (!form.hasValues(values)) return
        const checks = [
            form.shouldPromptToStoreData,
            this.passwordGenerator.generated
        ]

        if (checks.some(Boolean)) {
            const withAutoGeneratedFlag = appendGeneratedId(values, this.passwordGenerator.password)
            this.remoteData.storeFormData(withAutoGeneratedFlag)
        }
    }

    /**
     * Sends a pixel to be fired on the client side
     * @param {import('../deviceApiCalls/__generated__/validators-ts').SendJSPixelParams} pixelParams
     */
    firePixel(pixelParams) {
        this.deviceApi.notify(new SendJSPixelCall(pixelParams))
    }

    /**
     * This serves as a single place to create a default instance
     * of InterfacePrototype that can be useful in testing scenarios
     * @returns {InterfacePrototype}
     */
    static default() {
        const globalConfig = createGlobalConfig()
        const transport = createTransport('macos-legacy', globalConfig)
        const deviceApi = new DeviceApi(transport)
        const settings = Settings.default(globalConfig, deviceApi)
        return new InterfacePrototype('macos-legacy', globalConfig, deviceApi, settings)
    }
}

export default InterfacePrototype

/**
 * @param {never} x
 * @returns {never}
 */
function assertUnreachable(x) {
    console.log(x)
    throw new Error("Didn't expect to get here");
}
