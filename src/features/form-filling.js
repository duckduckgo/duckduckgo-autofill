import {SelectedDetailCall} from "../deviceApiCalls/__generated__/deviceApiCalls";
import {formatDuckAddress} from "../autofill-utils";
import {getMainTypeFromType, getSubtypeFromType} from "../Form/matching";
import {AUTOGENERATED_KEY, PROVIDER_LOCKED} from "../InputTypes/Credentials";

export class FormFilling {
    /**
     * @param {import("../DeviceInterface/InterfacePrototype").default} device
     */
    constructor(device) {
        this.device = device
    }
    /**
     * This indicates an item was selected, and we should try to autofill
     *
     * Note: When we're in a top-frame scenario, like on like macOS & Windows in the webview,
     * this method gets overridden {@see WindowsOverlayDeviceInterface} {@see AppleOverlayDeviceInterface}
     *
     * @param {IdentityObject|CreditCardObject|CredentialsObject|{email:string, id: string}} data
     * @param {string} type
     */
    async selectedDetail(data, type) {
        const defaultSelectedMethod = () => {
            const form = this.device.uiController.activeForm
            if (!form) {
                console.warn('form is no longer present');
                return
            }
            if (data.id === 'privateAddress') {
                this.device.emailProtection.refreshAlias().catch(console.error)
            }
            if (type === 'email' && 'email' in data) {
                form.autofillEmail(data.email)
            } else {
                form.autofillData(data, type)
            }
            this.device.removeTooltip('defaultSelectedMethod')
        }

        const selectedInOverlay = async () => {
            let detailsEntries = Object.entries(data).map(([key, value]) => {
                return [key, String(value)]
            })
            const entries = Object.fromEntries(detailsEntries)
            /** @link {import("../deviceApiCalls/schemas/getAutofillData.result.json")} */
            await this.device.deviceApi.notify(new SelectedDetailCall({data: entries, configType: type}))
        }

        switch (this.device.ctx) {
            case "macos-legacy":
            case "macos-modern":
            case "ios":
            case "android":
            case "windows":
            case "extension":
                return defaultSelectedMethod()
            case "macos-overlay":
            case "windows-overlay": {
                return selectedInOverlay();
            }
            default:
                assertUnreachable(this.device.ctx)
        }
    }
    /**
     * When an item was selected, we then call back to the device
     * to fetch the full suite of data needed to complete the autofill
     *
     * @param {import('../Form/matching').SupportedTypes} inputType
     * @param {(CreditCardObject|IdentityObject|CredentialsObject)[]} items
     * @param {CreditCardObject['id']|IdentityObject['id']|CredentialsObject['id']} id
     */
    onSelect(inputType, items, id) {
        id = String(id)
        const mainType = getMainTypeFromType(inputType)
        const subtype = getSubtypeFromType(inputType)

        if (id === PROVIDER_LOCKED) {
            return this.device.bitwarden.askToUnlockProvider()
        }

        const matchingData = items.find(item => String(item.id) === id)
        if (!matchingData) throw new Error('unreachable (fatal)')

        const dataPromise = (() => {
            switch (mainType) {
                case 'creditCards':
                    return this.device.remoteData.getAutofillCreditCard(id)
                case 'identities':
                    return this.device.remoteData.getAutofillIdentity(id)
                case 'credentials': {
                    if (AUTOGENERATED_KEY in matchingData) {
                        return Promise.resolve({success: matchingData})
                    }
                    return this.device.remoteData.getAutofillCredentials(id)
                }
                default:
                    throw new Error('unreachable!')
            }
        })()

        // wait for the data back from the device
        dataPromise.then(response => {
            if (response) {
                const data = response.success || response
                if (mainType === 'identities') {
                    this.device.firePixel({pixelName: 'autofill_identity', params: {fieldType: subtype}})
                    switch (id) {
                        case 'personalAddress':
                            this.device.firePixel({pixelName: 'autofill_personal_address'})
                            break
                        case 'privateAddress':
                            this.device.firePixel({pixelName: 'autofill_private_address'})
                            break
                        default:
                            // Also fire pixel when filling an identity with the personal duck address from an email field
                            const checks = [
                                subtype === 'emailAddress',
                                this.device.localData.hasLocalAddresses,
                                data?.emailAddress === formatDuckAddress(this.device.localData.addresses.personalAddress)
                            ]
                            if (checks.every(Boolean)) {
                                this.device.firePixel({pixelName: 'autofill_personal_address'})
                            }
                            break
                    }
                }
                // some platforms do not include a `success` object, why?
                return this.device.formFilling.selectedDetail(data, mainType)
            } else {
                return Promise.reject(new Error('none-success response'))
            }
        }).catch(e => {
            console.error(e)
            return this.device.removeTooltip('error caught after dataPromise')
        })
    }
}

/**
 * @param {never} x
 * @returns {never}
 */
function assertUnreachable(x) {
    console.log(x)
    throw new Error("Didn't expect to get here");
}
