import {
    createAutofillScript, defaultMacosScript,
    forwardConsoleMessages
} from '../helpers/harness.js'
import {test as base, expect} from '@playwright/test'
import {constants} from '../helpers/mocks.js'
import {createWebkitMocks, macosContentScopeReplacements} from '../helpers/mocks.webkit.js'
import {createAvailableInputTypes, stripDuckExtension} from '../helpers/utils.js'
import {testContext} from '../helpers/test-context.js'
import {signupPage} from '../helpers/pages/signupPage.js'
import {scannerPerf} from '../helpers/pages/scannerPerf.js'
import {emailAutofillPage} from '../helpers/pages/emailAutofillPage.js'
import { selectInputPage } from '../helpers/pages/selectInputPage.js'

/**
 *  Tests for various auto-fill scenarios on macos
 */
const test = testContext(base)

test.describe('macos', () => {
    test('should autofill the selected email', async ({page}) => {
        // enable in-terminal exceptions
        await forwardConsoleMessages(page)

        await createWebkitMocks()
            .withAvailableInputTypes({email: true})
            .withPrivateEmail('0')
            .withPersonalEmail('shane-123')
            .applyTo(page)

        // Load the autofill.js script with replacements
        await createAutofillScript()
            .replaceAll(macosContentScopeReplacements())
            .platform('macos')
            .applyTo(page)

        const {personalAddress, privateAddress0} = constants.fields.email

        // page abstraction
        const emailPage = emailAutofillPage(page)
        await emailPage.navigate()

        // first click into the field
        await emailPage.clickIntoInput()

        // these are mac specific - different to the extension because they use different tooltips (currently)
        const personalAddressBtn = await page.locator(`button:has-text("${personalAddress} Block email trackers")`)
        const privateAddressBtn = await page.locator(`button:has-text("Generate Private Duck Address 0@duck.com")`)

        // select the first option
        await expect(personalAddressBtn).toBeVisible()
        await personalAddressBtn.click({force: true})

        // ensure autofill populates the field
        await emailPage.assertEmailValue(personalAddress)

        // ensure pixel was fired
        await emailPage.assertPixelsFired([
            {pixelName: 'autofill_identity', params: {fieldType: 'emailAddress'}},
            {pixelName: 'autofill_personal_address'}
        ])

        // ensure the popup DOES show a second time, even though Dax was not clicked (this is mac specific)
        await emailPage.clickIntoInput()
        await expect(personalAddressBtn).toBeVisible()

        // now select the second address this time...
        await privateAddressBtn.click({force: true})

        // ...and ensure the second value is the private address
        await emailPage.assertEmailValue(privateAddress0)

        // ensure pixel was fired
        await emailPage.assertPixelsFired([
            {pixelName: 'autofill_identity', params: {fieldType: 'emailAddress'}},
            {pixelName: 'autofill_personal_address'},
            {pixelName: 'autofill_identity', params: {fieldType: 'emailAddress'}},
            {pixelName: 'autofill_private_address'}
        ])
    })
    test.describe('auto filling a signup form', () => {
        async function applyScript (page) {
            await createAutofillScript()
                .replaceAll(macosContentScopeReplacements())
                .platform('macos')
                .applyTo(page)
        }

        const {personalAddress, privateAddress0} = constants.fields.email
        const identity = constants.fields.identity
        const identityWithDuckAddress = {
            ...identity,
            emailAddress: personalAddress
        }
        test('using a private address (generated)', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withPrivateEmail('0')
                .withPersonalEmail('dax')
                .applyTo(page)

            await applyScript(page)

            await signup.navigate()
            await signup.clickIntoEmailField()
            await signup.selectPrivateAddress('0@duck.com')

            await signup.assertWasPromptedToSave({
                autogenerated: true,
                username: constants.fields.email.privateAddress0
            })

            await signup.enterPassword('abcd')
            await signup.submit()

            await signup.assertWasPromptedToSaveAgain({
                autogenerated: true,
                password: 'abcd',
                username: constants.fields.email.privateAddress0
            })
        })
        test('using a private address, but then editing it @flaky', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withPrivateEmail('0')
                .withPersonalEmail('dax')
                .applyTo(page)

            await applyScript(page)

            await signup.navigate()
            await signup.clickIntoEmailField()
            await signup.selectPrivateAddress('0@duck.com')

            await signup.assertWasPromptedToSave({
                autogenerated: true,
                username: constants.fields.email.privateAddress0
            })

            await signup.changeEmailFieldTo('dax@example.com')
            await signup.enterPassword('abcd')
            await signup.submit()

            /**
             * Here we're ensuring that the 'autogenerated' flag is no-longer being sent
             */
            await signup.assertWasPromptedToSaveAgain({
                password: 'abcd',
                username: 'dax@example.com'
            })
        })
        test('with an identity only - filling firstName + generated password', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withIdentity(identity)
                .applyTo(page)

            await applyScript(page)

            await signup.navigate()
            await signup.assertEmailHasNoDaxIcon()
            await signup.selectGeneratedPassword()
            await signup.selectFirstName(identity.firstName + ' Main identity')
            await signup.assertEmailValue(identity.emailAddress)
            await signup.assertPixelsFired([
                {pixelName: 'autofill_identity', params: {fieldType: 'firstName'}}
            ])
        })
        test('with an identity only - filling lastName', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withIdentity(identity)
                .applyTo(page)

            await applyScript(page)

            await signup.navigate()
            await signup.assertEmailHasNoDaxIcon()
            await signup.selectGeneratedPassword()
            await signup.selectLastName(identity.lastName + ' Main identity')
            await signup.assertEmailValue(identity.emailAddress)
            await signup.assertPixelsFired([
                {pixelName: 'autofill_identity', params: {fieldType: 'lastName'}}
            ])
        })
        test.only('with an identity only - filling touched select input without label', async ({page}) => {
            await forwardConsoleMessages(page)
            const selectInput = selectInputPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withIdentity(identity)
                .applyTo(page)

            await applyScript(page)

            await selectInput.navigate()
            await selectInput.selectOption('option2')
            await selectInput.selectFirstName(identity.firstName)
            await page.waitForTimeout(100)
            await selectInput.assertSelectedValue('option2')
        })
        test.only('with an identity only - filling touched select input with label', async ({page}) => {
            await forwardConsoleMessages(page)
            const selectInput = selectInputPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withIdentity(identity)
                .applyTo(page)

            await applyScript(page)

            await selectInput.navigate('selectInput', true)
            await selectInput.selectOption('option2', true)
            await selectInput.selectFirstName(identity.firstName, true)
            await page.waitForTimeout(100)
            await selectInput.assertSelectedValue('option2', true)
        })
        test('with an identity + Email Protection, autofill using duck address in identity', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withPersonalEmail(stripDuckExtension(personalAddress))
                .withPrivateEmail(stripDuckExtension(privateAddress0))
                .withIdentity(identityWithDuckAddress)
                .applyTo(page)

            await applyScript(page)

            await signup.navigate()
            await signup.selectGeneratedPassword()
            await signup.selectFirstEmailField(identityWithDuckAddress.emailAddress)
            await signup.assertEmailValue(identityWithDuckAddress.emailAddress)
            await signup.assertPixelsFired([
                {pixelName: 'autofill_identity', params: {fieldType: 'emailAddress'}},
                {pixelName: 'autofill_personal_address'}
            ])
        })
        test('with an identity + Email Protection, autofill using duck address in identity triggered from name field', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)

            await createWebkitMocks()
                .withAvailableInputTypes(createAvailableInputTypes())
                .withPersonalEmail(stripDuckExtension(personalAddress))
                .withPrivateEmail(stripDuckExtension(privateAddress0))
                .withIdentity(identityWithDuckAddress)
                .applyTo(page)

            await applyScript(page)

            await signup.navigate()
            await signup.selectGeneratedPassword()
            await signup.selectFirstName(identityWithDuckAddress.firstName)
            await signup.assertEmailValue(identityWithDuckAddress.emailAddress)
            await signup.assertPixelsFired([
                {pixelName: 'autofill_identity', params: {fieldType: 'firstName'}}
            ])
        })
        test('with no input types', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)
            await createWebkitMocks().applyTo(page)
            await applyScript(page)
            await signup.navigate()

            // should still allow password generation
            await signup.selectGeneratedPassword()
        })
    })
    test('autofill a newly added email form (mutation observer test)', async ({page}) => {
        // enable in-terminal exceptions
        await forwardConsoleMessages(page)

        const {personalAddress, privateAddress0} = constants.fields.email

        await createWebkitMocks()
            .withAvailableInputTypes({email: true})
            .withPersonalEmail(stripDuckExtension(personalAddress))
            .withPrivateEmail(stripDuckExtension(privateAddress0))
            .withIdentity(constants.fields.identity)
            .applyTo(page)

        // Load the autofill.js script with replacements
        await createAutofillScript()
            .replaceAll(macosContentScopeReplacements())
            .platform('macos')
            .applyTo(page)

        const signup = signupPage(page)
        await signup.navigate()
        await signup.addNewForm()
        await signup.selectSecondEmailField(personalAddress)
        await signup.assertSecondEmailValue(personalAddress)
        await signup.assertFirstEmailEmpty()
        await signup.assertPixelsFired([
            {pixelName: 'autofill_identity', params: {fieldType: 'emailAddress'}},
            {pixelName: 'autofill_personal_address'}
        ])
    })
    test.describe('matching performance', () => {
        test('real-world form', async ({page}) => {
            await createWebkitMocks().applyTo(page)
            await defaultMacosScript(page)

            const perfPage = scannerPerf(page)
            perfPage.navigate('pages/usps_signup.html')

            await perfPage.validateInitialScanPerf(200)
        })

        test('wall of 1000 fields with production settings', async ({page}) => {
            await createWebkitMocks().applyTo(page)
            await defaultMacosScript(page)

            const perfPage = scannerPerf(page)
            perfPage.navigate()

            // In production, we expect autofill to bail on such a page
            await perfPage.validateInitialScanPerf(10)
        })

        test('wall of 1000 fields with extreme settings', async ({page}) => {
            await createWebkitMocks().applyTo(page)
            await createAutofillScript()
                .replaceAll(macosContentScopeReplacements())
                .platform('macos')
                // Up the failsafe threshold to run the test
                .withConstants({
                    MAX_INPUTS_PER_PAGE: 2000,
                    MAX_INPUTS_PER_FORM: 2000
                })
                .applyTo(page)

            const perfPage = scannerPerf(page)
            perfPage.navigate()

            await perfPage.validateInitialScanPerf(300)
        })

        // This could cause a crash or hang in certain browsers (Webkit 17)
        test('large dom with potentially huge regex checks', async ({page}) => {
            // If this fails, the process is expected to crash or hang. The timeout hopefully shortens the feedback loop.
            test.setTimeout(5000)
            await createWebkitMocks().applyTo(page)
            await createAutofillScript()
                .replaceAll(macosContentScopeReplacements())
                .platform('macos')
                .applyTo(page)

            const perfPage = scannerPerf(page)
            perfPage.navigate(constants.pages['perf-huge-regex'])

            await perfPage.validateInitialScanPerf(80)
        })
    })
})
