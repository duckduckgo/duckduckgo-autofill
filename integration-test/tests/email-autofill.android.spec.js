import {
    createAutofillScript,
    forwardConsoleMessages
} from '../helpers/harness.js'
import {test as base} from '@playwright/test'
import {constants} from '../helpers/mocks.js'
import {androidStringReplacements, createAndroidMocks} from '../helpers/mocks.android.js'
import {testContext} from '../helpers/test-context.js'
import {signupPage} from '../helpers/pages/signupPage.js'
import {emailAutofillPage} from '../helpers/pages/emailAutofillPage.js'

/**
 *  Tests for email autofill on android tooltipHandler
 */
const test = testContext(base)

test.describe('android', () => {
    test.describe('when signed in', () => {
        test('should autofill the selected email', async ({page}) => {
            // enable in-terminal exceptions
            await forwardConsoleMessages(page)
            const emailPage = emailAutofillPage(page)
            await emailPage.navigate()

            // android specific mocks, withPersonalEmail will ensure the signed-in check works
            const {personalAddress} = constants.fields.email
            await createAndroidMocks()
                .withPersonalEmail(personalAddress)
                .withPrivateEmail(personalAddress)
                .applyTo(page)

            // create + inject the script
            await createAutofillScript()
                .replaceAll(androidStringReplacements())
                .platform('android')
                .applyTo(page)

            // if this works, the tooltipHandler must have loaded and added the field decorations
            await emailPage.clickIntoInput()

            // Because of the mock above, assume an email was selected and ensure it's autofilled
            await emailPage.assertEmailValue(personalAddress)
        })
        test('should store form data when using private or personal address', async ({page}) => {
            await forwardConsoleMessages(page)
            const signup = signupPage(page)
            await signup.navigate()

            const {personalAddress, privateAddress0} = constants.fields.email
            await createAndroidMocks()
                .withPersonalEmail(personalAddress)
                .withPrivateEmail(privateAddress0)
                .applyTo(page)

            await createAutofillScript()
                .replaceAll(androidStringReplacements({
                    featureToggles: {
                        credentials_saving: true
                    }
                }))
                .platform('android')
                .applyTo(page)

            await signup.clickIntoEmailField()
            await signup.enterPassword('abcd')
            await signup.submit()
            await signup.assertWasPromptedToSave({
                autogenerated: true,
                password: 'abcd',
                username: constants.fields.email.privateAddress0
            })
        })
    })
    test.describe('when availableInputTypes are available', () => {
        test('should use availableInputTypes.email', async ({page}) => {
            await forwardConsoleMessages(page)
            const emailPage = emailAutofillPage(page)
            await emailPage.navigate()
            const {personalAddress} = constants.fields.email
            await createAndroidMocks()
                .withPersonalEmail(personalAddress)
                .withPrivateEmail(personalAddress)
                .applyTo(page)

            // create + inject the script
            await createAutofillScript()
                .replaceAll(androidStringReplacements({
                    availableInputTypes: {
                        email: true
                    }
                }))
                .platform('android')
                .applyTo(page)

            await emailPage.clickIntoInput()
            await emailPage.assertEmailValue(personalAddress)
        })
    })
    test.describe('when not signed in', () => {
        test('should not decorate with Dax icon', async ({page}) => {
            // enable in-terminal exceptions
            await forwardConsoleMessages(page)

            // page abstraction
            const signup = signupPage(page)
            await signup.navigate()

            // android specific mocks
            await createAndroidMocks()
                .applyTo(page)

            // create + inject the script
            await createAutofillScript()
                .replaceAll(androidStringReplacements({
                    availableInputTypes: {
                        email: false
                    }
                }))
                .platform('android')
                .applyTo(page)

            await signup.assertEmailHasNoDaxIcon()
        })
    })
    test.describe('password generation', () => {
        const script = createAutofillScript()
            .replaceAll(androidStringReplacements({
                availableInputTypes: {},
                featureToggles: {
                    password_generation: true,
                    inputType_credentials: true,
                    inlineIcon_credentials: true,
                    credentials_saving: true
                }
            }))
            .platform('android')

        test('should autofill with generated password + private email', async ({page}) => {
            // enable in-terminal exceptions
            await forwardConsoleMessages(page)
            const signup = signupPage(page)
            await signup.navigate()

            const {personalAddress, privateAddress0} = constants.fields.email
            await createAndroidMocks()
                .withPersonalEmail(personalAddress)
                .withPrivateEmail(privateAddress0)
                .withPasswordDecision?.('accept')
                .applyTo(page)

            await script.applyTo(page)

            // simulate the email modal
            await signup.clickIntoEmailField()

            // simulate the password generation modal
            await signup.clickIntoPasswordField()

            // asserting that the modal was opened with correct data
            await signup.assertUsernameFieldSent(privateAddress0)

            // make sure the password was filled
            await signup.assertPasswordWasAutofilled()
        })

        test('should not autofill when password rejected', async ({page}) => {
            // enable in-terminal exceptions
            await forwardConsoleMessages(page)
            const signup = signupPage(page)
            await signup.navigate()

            // android specific mocks
            await createAndroidMocks()
                .withPasswordDecision?.('reject')
                .applyTo(page)

            // create + inject the script
            await script.applyTo(page)

            await signup.clickIntoPasswordField()
            await signup.assertPasswordWasNotAutofilled()

            // should not prompt again on second password field (which will be untouched)
            await signup.clickIntoPasswordConfirmationField()
            await signup.assertPasswordWasSuggestedTimes(1)

            // SHOULD prompt again if icon clicked though, since that's explicit opt-in
            await signup.clickDirectlyOnPasswordIcon()
            await signup.assertPasswordWasSuggestedTimes(2)
        })
    })
})
